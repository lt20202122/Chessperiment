# chessperiment Technical Documentation & Logic Manifesto ('llms-full.txt')

> **System Purpose**: chessperiment is a generative platform for custom chess variants, allowing users to define pieces with complex move algorithms, visual logic flows, and reactive event triggers. This document flattens the core logic, schema definitions, and visual scripting reference for AI ingestion.

---

## 1. The Logic Manifesto

chessperiment moves beyond standard FIDE chess rules by introducing a "Logic Layer" on top of the standard grid. While the underlying board is a standard 8x8 (resizeable) grid, piece behavior is defined by **Move Rules** and **Event Blocks**.

### The "Non-Grid" Abstraction
Although visually utilizing a grid, the logic engine treats movement as a set of **Vector Constraints** rather than fixed patterns. A "Knight Jump" is not "2 up 1 right" but rather `(absDiffX === 1 AND absDiffY === 2) OR (absDiffX === 2 AND absDiffY === 1)`.

### Conditional Logic Structure
The engine evaluates moves in two passes:
1.  **Travel Validation (The "Visual Move Editor")**:
    *   Evaluates purely geometric possibility (`diffX`, `diffY`).
    *   Determines if a square is reachable *in vacuum*.
    *   Result: `Allow` or `Disallow`.
2.  **State Validation (The "Block Editor")**:
    *   Evaluates context (`onCapture`, `onThreat`, `onEnvironment`).
    *   Executes side effects (`Transformation`, `Cooldown`).
    *   Can override Travel Validation (e.g., `Prevent Default` block).

---

## 2. API & Schema References

### The `MoveRule` Schema (Visual Move Editor)
This schema defines the geometric constraints for a piece's movement.

```typescript
type Operator = '===' | '>' | '<' | '>=' | '<=';
type Variable = 'diffX' | 'diffY' | 'absDiffX' | 'absDiffY';

interface MoveCondition {
    id: string;
    variable: Variable;
    operator: Operator;
    value: number;
    logic?: 'AND' | 'OR'; // Chaining logic
}

interface MoveRule {
    id: string;
    conditions: MoveCondition[]; // All conditions must pass (unless OR is used)
    result: 'allow' | 'disallow'; // If conditions match, is this move legal?
}
```

**Variable Reference:**
*   `diffX`: Raw X distance (Target X - Start X). Positive = Right, Negative = Left.
*   `diffY`: Raw Y distance (Target Y - Start Y). Positive = Down (usually), Negative = Up.
*   `absDiffX`: Absolute X distance. Useful for symmetric moves (e.g., "move 1 square left or right").
*   `absDiffY`: Absolute Y distance.

### The `LogicBlock` Schema (Event Editor)
This purely visual "Scratch-like" language handles complex game events.

```typescript
type BlockCategory = 'Trigger' | 'Effects' | 'Variables';
type BlockType = 'trigger' | 'effect' | 'terminal' | 'variable';

interface SocketConfig {
    id: string; // e.g., 'duration', 'target'
    type: 'number' | 'text' | 'select';
    options?: string[]; // For 'select' type
}

interface BlockInstance {
    instanceId: string;
    type: BlockType;
    category: BlockCategory;
    parentId?: string; // ID of the block "above" this one
    childId?: string;  // ID of the block "below" this one
    socketValues: Record<string, any>; // User-configured values
}
```

---

## 3. The Block Library (Reference)

### Triggers (The "When")
Blocks that start a logic chain.

*   **`onCapture`**: Fires when *this* piece captures another.
    *   *Sockets*: `by` (Filter target type: 'Pawn', 'King', etc.)
*   **`onCaptured`**: Fires when *this* piece IS captured.
    *   *Sockets*: `by` (Filter attacker type)
*   **`onThreat`**: Fires when *this* piece is targeted by an enemy move.
*   **`onMove`**: Fires immediately after a successful move.
*   **`onEnvironment`**: Fires based on static board state.
    *   *Options*: 'White Square', 'Black Square', 'Is Attacked'.
*   **`onVar`**: Fires when a custom variable meets a condition.

### Effects (The "Then")
Blocks that modify game state.

*   **`Transformation`**: Morphs the piece into another type (e.g., Pawn -> Queen).
*   **`Cooldown`**: Disables the piece for `N` turns/moves.
*   **`Modify Var`**: Changes a custom numeric variable (`+=`, `-=`, `=`).
*   **`Mode`**: Sets a strictly textual "mode" for the piece (stateless tag).

### Terminals & Control
*   **`Kill`**: Removes a piece from the board.
    *   *Target*: 'Selected Piece' (Suicide) or 'Attacker' (Revenge).
*   **`Prevent Default`**: **CRITICAL**. Stops the engine's default action.
    *   *Usage*: Put inside `onCaptured` to make a piece invincible (it prevents the capture).

---

## 4. The Cookbook: Logic Patterns

### Example 1: The "Drunk Rook"
*Description*: Moves like a Rook, but only 1 or 2 squares.
**Visual Move Editor Rules**:
1.  **Horizontal**: `absDiffY === 0` AND `absDiffX <= 2` -> **Allow**
2.  **Vertical**: `absDiffX === 0` AND `absDiffY <= 2` -> **Allow**

### Example 2: The "Phoenix"
*Description*: When captured, it doesn't die. Instead, it turns into a Pawn.
**Logic Blocks**:
1.  **Trigger**: `onCaptured` (by: Any)
2.  **Child**: `Prevent Default` (Stops the death)
3.  **Child**: `Transformation` (Target: Pawn)

### Example 3: The "Berserker"
*Description*: Gains a "Rage" stack on every capture. If Rage > 3, it explodes (dies).
**Logic Blocks**:
1.  **Trigger**: `onCapture`
2.  **Child**: `Modify Var` (Var: "Rage", Op: `+=`, Value: 1)
3.  **Trigger**: `onVar` (Var: "Rage", Op: `>`, Value: 3)
4.  **Child**: `Kill` (Target: Selected Piece)

### Example 4: The "Pacifist"
*Description*: Cannot capture enemies. Can only move to empty squares.
**Logic Blocks**:
1.  **Trigger**: `onCapture`
2.  **Child**: `Prevent Default` (Cancels the move if it results in a capture)

---

## 5. Troubleshooting & FAQ

### Why isn't my logic firing?
*   **Check Parent/Child Links**: Blocks must be physically snapped together. A floating `Kill` block will never execute.
*   **Trigger Context**: `onCapture` only fires *during* the capture event. You cannot put a `Prevent Default` inside `onMove` to stop a capture, because `onMove` happens *after* the board updates. Use `onCapture` to intercede.

### "Prevent Default" doesn't work on `onThreat`?
Correct. `onThreat` is a passive check (it highlights the piece). You cannot "prevent" a threat; you can only prevent the *move* that causes the threat or the *capture* that results from it.

### How do I make a piece jump?
In **Visual Move Editor**, jumping is implicit if you don't define "slide" behavior.
*   If you just define `absDiffX === 2`, the piece "teleports" to +2.
*   If you want it to be blocked by pieces in between, you implicitly need the engine's "slider" logic (currently default for Rook/Bishop/Queen base types, but custom logic is usually "Teleport" based in this engine version). *Note: Future updates will expose 'Collide' properties.*
